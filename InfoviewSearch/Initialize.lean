/-
Copyright (c) 2024 Jovan Gerbscheid. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jovan Gerbscheid
-/
module

public import Mathlib.Lean.Meta.RefinedDiscrTree.Initialize
public import Lean.Meta.CompletionName

/-!
This is an updated version of `Mathlib.Lean.RefinedDiscrTree.Initialize`, with improved performance.
# Constructing a RefinedDiscrTree

`RefinedDiscrTree` is lazy, so to add an entry, we need to compute
the first `Key` and a `LazyEntry`. These are computed by `initializeLazyEntry`.

We provide `RefinedDiscrTree.insert` for directly performing this insert.

For initializing a `RefinedDiscrTree` using all imported constants,
we provide `createImportedDiscrTree'`, which loops through all imported constants,
and does this with a parallel computation.

There is also `createModuleDiscrTree'` which does the same but with the constants
from the current file.

-/

public section

namespace InfoviewSearch.RefinedDiscrTree
open Lean Meta RefinedDiscrTree

variable {α : Type}

/--
Structure for quickly initializing a lazy discrimination tree with a large number
of elements using concurrent functions for generating entries.

This preliminary structure is converted to a `RefinedDiscrTree` via `toRefinedDiscrTree`.
-/
private structure PreDiscrTree (α : Type) where
  /-- Maps keys to index in tries array. -/
  root : Std.HashMap Key Nat := {}
  /-- Lazy entries for root of trie. -/
  tries : Array (Array (LazyEntry × α)) := #[]
  deriving Inhabited

namespace PreDiscrTree

@[specialize]
private def push (d : PreDiscrTree α) (e : Key × (LazyEntry × α)) : PreDiscrTree α :=
  let { root, tries } := d
  let (k, e) := e
  match root[k]? with
  | none =>
    { root := root.insert k tries.size, tries := tries.push (#[e]) }
  | some i =>
    { root, tries := tries.modify i (·.push e) }

/-- Convert a `PreDiscrTree` to a `RefinedDiscrTree`. -/
private def toRefinedDiscrTree (d : PreDiscrTree α) : RefinedDiscrTree α :=
  let { root, tries } := d
  { root, tries := tries.map fun pending => .node #[] none {} {} pending }

end PreDiscrTree

/-- Information about a failed import. -/
private structure ImportFailure where
  /-- Module containing the constant whose import failed. -/
  module : Name
  /-- Constant whose import failed. -/
  const : Name
  /-- Exception that triggered the error. -/
  exception : Exception

/-- Information generated from imported modules. -/
private structure ImportErrorRef where
  errors : IO.Ref (Array ImportFailure)

private def ImportErrorRef.new : BaseIO ImportErrorRef := do
  return { errors := ← IO.mkRef #[] }

/-- Return true if `declName` is automatically generated,
or otherwise unsuitable as a lemma suggestion. -/
def blacklistInsertion (env : Environment) (declName : Name) : Bool :=
  declName.isInternalDetail ||
  declName.isMetaprogramming ||
  !allowCompletion env declName ||
  Linter.isDeprecated env declName ||
  declName == ``sorryAx ||
  (declName matches .str _ "inj" | .str _ "injEq" | .str _ "sizeOf_spec")

/--
Add the entries generated by `act name constInfo` to the `PreDiscrTree`.

Note: It is expensive to create two new `IO.Ref`s for every `MetaM` operation,
  so instead we reuse the same refs `mstate` and `cstate`. These are also used to
  remember the cache, and the name generator across the operations.
-/
@[inline] private def addConstToPreDiscrTree
    (cctx : Core.Context)
    (env : Environment)
    (modName : Name)
    (data : ImportErrorRef)
    (mstate : IO.Ref Meta.State)
    (cstate : IO.Ref Core.State)
    (act : Name → ConstantInfo → MetaM (List (α × List (Key × LazyEntry))))
    (arr : Array (Key × (LazyEntry × α))) (name : Name) (constInfo : ConstantInfo) :
    BaseIO (Array (Key × (LazyEntry × α))) := do
  -- here we use an if-then-else clause instead of the more stylish if-then-return,
  -- because it compiles to more performant code
  if constInfo.isUnsafe then pure arr else
  if blacklistInsertion env name then pure arr else
  /- For efficiency, we leave it up to the implementation of `act` to reset the states if needed -/
  -- mstate.modify fun s => { cache := s.cache }
  -- cstate.modify fun s => { env := s.env, cache := s.cache, ngen := s.ngen }
  let mctx := { keyedConfig := Config.toConfigWithKey { transparency := .reducible } }
  match ← (((act name constInfo) mctx mstate) cctx cstate).toBaseIO with
  | .ok a =>
    return a.foldl (init := arr) fun arr (val, entries) =>
      entries.foldl (init := arr) fun arr (key, entry) => arr.push (key, (entry, val))
  | .error e =>
    let i : ImportFailure := {
      module := modName,
      const := name,
      exception := e }
    data.errors.modify (·.push i)
    return arr

/--
Loop through all constants that appear in the module `mdata`,
and add the entries generated by `act` to the `PreDiscrTree`.
-/
private partial def loadImportedModule
    (cctx : Core.Context)
    (env : Environment)
    (data : ImportErrorRef)
    (mstate : IO.Ref Meta.State)
    (cstate : IO.Ref Core.State)
    (act : Name → ConstantInfo → MetaM (List (α × List (Key × LazyEntry))))
    (mname : Name)
    (mdata : ModuleData)
    (arr : Array (Key × (LazyEntry × α)))
    (i : Nat := 0) : BaseIO (Array (Key × (LazyEntry × α))) := do
  if h : i < mdata.constNames.size then
    let name := mdata.constNames[i]
    let constInfo := mdata.constants[i]!
    let state ← addConstToPreDiscrTree cctx env mname data mstate cstate act arr name constInfo
    loadImportedModule cctx env data mstate cstate act mname mdata state (i+1)
  else
    return arr

/--
Loop through all constants that appear in the modules with module index from `start` to `stop - 1`,
and add the entries generated by `act` to the `PreDiscrTree`.
-/
private def createImportInitResults (cctx : Core.Context) (ngen : NameGenerator)
    (data : ImportErrorRef)
    (env : Environment) (act : Name → ConstantInfo → MetaM (List (α × List (Key × LazyEntry))))
    (start stop : Nat) : BaseIO (Array (Key × (LazyEntry × α))) := do
  go start stop #[] (← IO.mkRef {}) (← IO.mkRef { env, ngen })
where
  go (start stop : Nat) (arr : Array (Key × (LazyEntry × α)))
      (mstate : IO.Ref Meta.State)
      (cstate : IO.Ref Core.State) :
      BaseIO (Array (Key × (LazyEntry × α))) := do
    if start < stop then
      let mname := env.header.moduleNames[start]!
      let mdata := env.header.moduleData[start]!
      let tree ← loadImportedModule cctx env data mstate cstate act mname mdata arr
      go (start+1) stop arr mstate cstate
    else
      return arr
  termination_by stop - start

private def getChildNgen : CoreM NameGenerator := do
  let ngen ← getNGen
  let (cngen, ngen) := ngen.mkChild
  setNGen ngen
  pure cngen

private def logImportFailures (ref : ImportErrorRef) : CoreM Unit := do
  (← ref.errors.get).forM fun f ↦
    logError m!"Processing failure with {f.const} in {f.module}:\n  {f.exception.toMessageData}"

/--
Create a `RefinedDiscrTree` consisting of all entries generated by `act`
from imported constants; `addConstToPreDiscrTree` calls this helper.
This uses parallel computation.
-/
def createImportedDiscrTree' (ngen : NameGenerator) (env : Environment)
    (act : Name → ConstantInfo → MetaM (List (α × List (Key × LazyEntry))))
    (constantsPerTask : Nat) :
    CoreM (RefinedDiscrTree α) := do
  let numModules := env.header.moduleData.size
  let cctx ← read
  let data ← ImportErrorRef.new
  let rec
    /-- Allocate constants to tasks according to `constantsPerTask`. -/
    go (ngen : NameGenerator) (tasks : Array (Task (Array (Key × (LazyEntry × α)))))
        (start cnt idx : Nat) := do
      if h : idx < numModules then
        let mdata := env.header.moduleData[idx]
        let cnt := cnt + mdata.constants.size
        if cnt > constantsPerTask then
          let (childNGen, ngen) := ngen.mkChild
          let t ← (createImportInitResults
            cctx childNGen data env act start (idx+1)).asTask
          go ngen (tasks.push t) (idx+1) 0 (idx+1)
        else
          go ngen tasks start cnt (idx+1)
      else
        if start < numModules then
          let (childNGen, _) := ngen.mkChild
          let t ← (createImportInitResults
            cctx childNGen data env act start numModules).asTask
          pure (tasks.push t)
        else
          pure tasks
    termination_by env.header.moduleData.size - idx
  let tasks ← go ngen #[] 0 0 0
  let tree : PreDiscrTree α := tasks.foldl (init := {}) fun pre task ↦ task.get.foldl .push pre
  logImportFailures data
  return tree.toRefinedDiscrTree

/--
A discriminator tree for the current module's declarations only.

Note: We use different discrimination trees for imported and current module
declarations since imported declarations are typically much more numerous but
not changed while the current module is edited.
-/
structure ModuleDiscrTreeRef (α : Type _) where
  /-- The reference to the `RefinedDiscrTree`. -/
  ref : IO.Ref (RefinedDiscrTree α)

private def createModulePreDiscrTree
    (cctx : Core.Context)
    (ngen : NameGenerator)
    (data : ImportErrorRef)
    (env : Environment)
    (act : Name → ConstantInfo → MetaM (List (α × List (Key × LazyEntry)))) :
    BaseIO (PreDiscrTree α) := do
  let modName := env.header.mainModule
  env.constants.map₂.foldlM (init := {}) fun pre name cinfo ↦ do
    let arr ← addConstToPreDiscrTree
      cctx env modName data (← IO.mkRef {}) (← IO.mkRef { env, ngen }) act #[] name cinfo
    return arr.foldl .push pre

/--
Create a `RefinedDiscrTree` for current module declarations, consisting of all
entries generated by `act` from constants in the current file.
This is called by `addConstToPreDiscrTree`.
-/
def createModuleDiscrTree' (act : Name → ConstantInfo → MetaM (List (α × List (Key × LazyEntry)))) :
    CoreM (RefinedDiscrTree α) := do
  let env ← getEnv
  let ngen ← getChildNgen
  let ctx ← readThe Core.Context
  let data ← ImportErrorRef.new
  let tree ← createModulePreDiscrTree ctx ngen data env act
  logImportFailures data
  return tree.toRefinedDiscrTree

/--
Create a reference for a `RefinedDiscrTree` for current module declarations.
-/
def createModuleTreeRef' (act : Name → ConstantInfo → MetaM (List (α × List (Key × LazyEntry)))) :
    MetaM (ModuleDiscrTreeRef α) := do
  profileitM Exception "build module discriminator tree" (← getOptions) do
    let t ← createModuleDiscrTree act
    pure { ref := ← IO.mkRef t }

end InfoviewSearch.RefinedDiscrTree
